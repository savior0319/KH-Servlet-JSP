─────────────────────────────────────────────────────────────────────────────────────────────────

@ 서블릿의 라이프 사이클
-> 라이프 사이클은 생명 주기를 뜻함
-> 서블릿이 다른 웹 기술보다 뛰어난 점은 빠른 수행 속도에 있음
-> 타 웹 기술 (PHP, ASP 등)들은 인터프리터 방식으로 해당 페이지들 마다 서버에서
매번 해석하면서 코드를 작동 시키지만 서블릿은 첫 번째 요청인 경우에는 서블릿 클래스를
찾아 메모리에 로딩하여 인스턴스(객체)를 생성하게 됨
-> 이후 부터의 요청은 생성된 인스턴스가 메모리에 계속 남아 있게 되므로
해당 서블릿을 호출하여도 새롭게 생성되지 않고 이미 메모리에 로딩된 상태의 서블릿으로 부터
서비스 처리를 받기 때문에 수행 속도가 빠름
-> 즉, 서블릿은 호출 때 마다 새롭게 객체를 생성하는 것이 아닌 단 1번만 생성하고
이후에는 서버(톰캣)가 종료되기 전까지는 해당 객체를 계속 재활용 함
(그렇기 때문에 서블릿 코드가 변경되면 톰캣을 재시작해야 하는 불편함은 존재함)
(ASP, JSP, PHP는 서버가 가동 후에 코드가 변경되어도 서버를 재시작할 필요는 없음)

─────────────────────────────────────────────────────────────────────────────────────────────────

@ HTTP 통신 방법
-> HTTP는 Server와 Client가 통신을 할 때 요청에 대한 응답을 하고 나면
연결된 세션을 끊어 버림 (stateless 방식)

-> Client는 서버에게 다른 서비스를 요청하려면 새로운 새션 연결을 맺고
요청 및 응답을 진행 함

※ 웹은 수 많은 클라이언트들의 연결을 처리 하기 위해 연결 상태를 유지 하지 않는
stateless 방식을 쓰고 있음(반대 개념 stateful)

@ stateless를 사용함으로써 발생하는 문제점
-> 연결 유지 상태가 아닌 매번 연결이 끊어 지기 때문에 유지 되어야 하는 정보들이 사라지게 됨
(로그인을 하여도 결국 세션이 끊어지게 되면 로그인 성공 했다라는 정보가 없음)

@ Cookie와 Session 값
-> 연결이 끊어진 이후에도 Client에 대한 정보를 유지하기 위해 Client에 연결 정보를 저장하는 방법
(Cookie)과 Server 측에 연결정보를 저장하는 방법(Session)이 있음

-> Client에 연결 정보를 저장하는 방법을 Cookie를 이용한 방법이라 하고, Server측에 연결 정보를
저장하는 방법을 Session을 이용한 방법이라고 함

※ 보안상 Client에 저장했던 Cookie 방식은 로그인 연결 정보를 저장하기에는 부적합하여 현재는 사용하지 않는 방식임
(Cookie가 탈취 당하면 연결 정보가 탈취 당하는 것과 같음 현재는 거의 모든 웹들이 Session 방식을 사용 함)


@ Session
-> 서버에 데이터를 저장하는 기술로 Client에는 Session ID(token)을 부여하고,
Client가 request에 Session ID를 넣어 보내면 Session ID를 기준으로 일치하는 Session을 찾아 정보를 사용 함
-> 만일  Client가 보낸 Session ID가 없으면 새롭게 발급 함

@ Session 객체
-> Session 객체는 개발자가 수동으로 객체를 생성하는 것이 아닌 컨테이너가 자동으로 생성하는 것이고,
개발자는 Session 객체를 가져다 쓰면 됨 (getSession() 메소드)

-> getSession() 메소드는 HttpRequest에 있음

## getSession() ##
-> 사용 방법 두가지
    1. HttpRequest.getSession(); 또는 HttpRequest.getSession(true);
    2. HttpRequest.getSession(false);

1. SessionID 일치 여부 확인 및 생성(있으면 해당 Session을 사용하고 없으면 새롭게 생성함)
2. SessionID 일치 여부 확인 (있으면 해당 Session을 사용함 없으면 null을 리턴함)

## Session과 관련된 메소드 ##

setAtrribute(String, object)
-> request 객체에 전달하고 싶은 값을 String 이름으로 Object에 저장하는 메소드
-> String이 Key 역할이고 Object가 Value 역할임

getAtrribute(String)
-> 해당 매개변수와 동일한 객체 속성 값을 가져오는 메소드
-> String이 key가 되고, 해당 Key에 맞는 값을 가져옴

removeAtrribute(String)
-> request객체에 저장되어 있는 값 중 매개변수와 동일한 속성 값을 삭제하는 메소드
-> String을 작성하게 되면 해당 값을 삭제함

getId()
-> 발급되는 SessionID 값을 가져옴

getCreateionTime()
-> Session 객체가 생선된 시간을 반환

isvalidate()
-> 해당 세션을 파기 (삭제)

setMaxinactiveInterval(int)
-> 객체의 유지 시간을 설정, 지정된 시간이 지나면 객체 자동 삭제

getAttributeNames()
-> 객체에 저장되어 있는 모든 정보의 이름만 변경

─────────────────────────────────────────────────────────────────────────────────────────────────

@ JSP란?
-> 동적인 웹 페이지를 Java언어를 이용하여 html 기반으로 작성 할 수 있는 기술을 말함
-> Servlet은 수정 시 재 컴파일(서버 리부팅)을 해야 하지만 jsp는 동적으로
컴파일 하기 때문에 서버를 리부팅 할 필요 없이 유연성있게 작업이 가능함
-> 또한, 기존 Servlet은 자바 언어가 "주" 언어로 활용되기 때문에
Web Page를 표현하려면 자바 언어를 핵심적으로 공부해야만 Web Page를 표현 할 수 있었음
-> 하지만 JSP는 "주" 언어가 html이라고 보면 됨 (HTML이 주 이지만 자바 언어를 쓸 수 있음)

※ 파일명이 .html로 끝나게 되면 html만 작성이 가능하지만 파일명이 .jsp로 끝나게 되면
HTML + Java를 사용 할 수 있음

@ JSP 특징
-> JSP 파일이 변경 되어도 서버를 리부트 할 필요가 없음 (인터프리터 방식)
-> JSP 파일이 변경 될 때마다, 컨테이너는 자동으로 translation, compile, load, initialization 과정을
수행함 (즉, 자동으로 매 요청시 마다 컴파일 작성 및 실행 함)
-> JSP 파일의 배포 환경(위치)은 HTML 폴더와 동일 함
    => WEB_ROOT 폴더 하단에 위치 (ex. WebContent\ )

─────────────────────────────────────────────────────────────────────────────────────────────────

@ JSP 실행 순서

1. Client가 JSP 파일을 요청 (ex. http://localhost:8888/web1/jsp/xx.jsp)
2. JSP Container가 XX.JSP 파일을 XX_jsp.java 파일로 컴파일
    (JSP 안에는 자바 코드가 있으므로 Java 코드로 컴파일 해야 함)
3. XX_jsp.java 파일을 다시 XX_jsp.class 파일로 컴파일 (자바 머신이 사용하기 위한 바이트 코드)
4. Servlet Container가 XX_jsp.class 파일의 코드를 실행
5. 실행의 결과를 View 전용 jsp 파일을 이용하여 응답해줌

─────────────────────────────────────────────────────────────────────────────────────────────────